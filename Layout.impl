IMPLEMENTATION Layout

IMPORT WinConfig ONLY point @
       String COMPLETELY
       StringConv COMPLETELY
       WinFontMetrics COMPLETELY
       Real COMPLETELY
       Nat  COMPLETELY
       Pair COMPLETELY
       Denotation COMPLETELY
       Settings COMPLETELY
       Syntax COMPLETELY
       Compose COMPLETELY

IMPORT Seq COMPLETELY
       SeqMap COMPLETELY
       SeqMapEnv COMPLETELY
       SeqOfSeq COMPLETELY
       SeqReduce COMPLETELY
       SeqZip COMPLETELY

DATA posWord == posWord(text : string, pos : point, width : real)
DATA word == word(text : string, width : real)

-- FUN layout : metrics ** body -> seq[posWord]
-- posWord(word1, @( left, margin), 0) :: <>

DEF layout(metr, body(pars)) == layoutPars(metr,pars)
DEF layout(metr, fail) == <>


-- Calculate Layout for all paragraphs
FUN layoutPars : metrics ** seq[par] -> seq[posWord]
DEF layoutPars(metr, <>) == <>
DEF layoutPars(metr, par(align, words) :: rt) == 
    layoutPar(align, break(wordWidths)) ++ layoutPars(metr, rt)
    WHERE
        widths == getWidth(metr) * (words)
        wordWidths == zip(word)(words,widths)


FUN layoutPar : alignment ** seq[seq[word]] -> seq[posWord]
DEF layoutPar(_, <>) == <>
DEF layoutPar(align, line :: rt) ==
    layoutLine(align, line) ++ layoutPar(align, rt)

        

FUN layoutLine : alignment ** seq[word] -> seq[posWord]
DEF layoutLine(_, <>) == <>
DEF layoutLine(align, word :: rt ) == <>



FUN break : seq[word] -> seq[seq[word]]
DEF break(<>) == <>
DEF break(word :: rt) == 
    LET 
        wordWidth       == width(word)
        k               == 1 + fit(usableWidth - wordWidth)(rt)
        (line, trailer) == split(k, rt)
    IN
        line :: break(trailer)


FUN fit : real -> seq[word] -> nat
DEF fit(supply)(<>) == 0
DEF fit(supply)(word :: rt) == 
    LET 
        needed == glue + width(word)
    IN
        IF      needed <= supply THEN 1 + fit(supply - needed)(rt)
        ELSE    0
        FI



FUN getWidth : metrics -> string -> real
DEF getWidth(metr)(str) == w
  WHERE
    (w,h) == dimensions(metr)(`(str)) 
    
  

-- write a function that accepts a p
--FUN stringsToDenotations : seq[]

--FUN first : (real ** real) -> real
--DEF first( one, two ) == one

--DEF layout(metrics, body(par(right,content) :: rt)) == <>
--DEF layout(metrics, body(par(center,content) :: rt)) == <>
--DEF layout(metrics, body(par(justify,content) :: rt)) == <>



DEF testBody == body( par(left, seq1) ::
                      par(right, seq2) ::
                      par(center, seq1) ::
                      par(justify, seq2) :: <>)

FUN word1 word2 word3 word4 word5 word6 : string
DEF word1 == !("Lorem")
DEF word2 == !("ipsum")
DEF word3 == !("dolor")
DEF word4 == !("sit")
DEF word5 == !("amet")
DEF word6 == !("consetetur") 


FUN seq1 seq2 : seq[string]
DEF seq1 == word1 :: word3 :: word5 :: word1 :: word3 :: word5 :: word1 :: word3 :: word5 :: <>
DEF seq2 == word2 :: word2 :: word6 :: word4 :: word2 :: word5 :: word4 :: word2 :: word6 :: <>